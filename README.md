# Исследование алгоритмов поиска кратчайшего пути
## Цель
Экспериментальное исследование алгоритмов поиска кратчайшего пути в неориентированном графе.

## Рассматриваемые алгоритмы
1)	Алгоритмы Дейкстры
2) Флойда-Уоршелла
3) Форда-Беллмана
4) Поиска А*

## Порядок проведения:
1. Необходимо сгенерировать тестовые данные трех типов (граф –
неориентированный):
a. Полные графы с числом вершин от 10 до 1010 (шаг 50)
b. Связные графы с числом вершин от 10 до 1010 (шаг 50) и коэффициентом
плотности приблизительно 0.4-0.5
c. Разреженные графы (деревья, обратите внимание, что граф должен быть
связным) с числом вершин от 10 до 1010 (шаг 50)
2. Стартовую и конечную вершину для всех алгоритмов выбирать одинаково.
3. Замерить время работы (в наносекундах) для алгоритмов
4. Построить графики зависимости отдельно по каждому алгоритму: a. Времени работы от числа вершин
b. Времени работы от числа ребер
5. Построить агрегированные графики зависимости (т.е. все алгоритмы на одном графике):
a. Времени работы от числа вершин
b. Времени работы от числа ребер
6. Сделать выводы об асимптотике алгоритмов и их применимости

# Результаты работы
## 1)	а. Время работы от числа вершин
### Алгоритм Дейкстры
![Alt text](/grafics/image-1.png)
### Алгоритм Флойда-Уоршелла
![Alt text](/grafics/image-2.png)
### Алгоритм Форда-Беллмана
![Alt text](/grafics/image-3.png)
### Поиск А*
![Alt text](/grafics/image-4.png)
## Вывод по графикам
Поиск А*, алгоритм Форда-Беллмана и Дейкстры проявляют сходные характеристики: наилучшую эффективность демонстрируют на разреженных графах и наихудшую - на полных графах. Алгоритм Флойда-Уоршелла менее эффективен на связных графах по сравнению с другими типами графов.

## 1)	b. Время работы от числа ребер
### Алгоритм Дейкстры
#### Полный
![Alt text](/grafics/image-7.png)
#### Разреженный
![Alt text](/grafics/image-8.png)
#### Связный
![Alt text](/grafics/image-9.png)
### Алгоритм Флойда-Уоршелла
#### Полный
![Alt text](/grafics/image-10.png)
#### Разреженный
![Alt text](/grafics/image-11.png)
#### Связный
![Alt text](/grafics/image-12.png)
### Алгоритм Форда-Беллмана
#### Полный
![Alt text](/grafics/image-13.png)
#### Разреженный
![Alt text](/grafics/image-14.png)
#### Связный
![Alt text](/grafics/image-15.png)
### Поиск А*
#### Полный
![Alt text](/grafics/image-16.png)
#### Разреженный
![Alt text](/grafics/image-17.png)
#### Связный
![Alt text](/grafics/image-18.png)
## Вывод по графикам
Алгоритмы Форда-Беллмана и Флойда-Уоршелла проявляют стабильность на всех типах графов, так как обработка разреженных графов, имеющих меньшее количество ребер, занимает меньшее время, чем полных и связных графов. Алгоритм Поиска А* работает значительно быстрее на разреженных графах, так как они содержат меньше ребер, но менее стабилен на полных и связных графах. Алгоритм Дейкстры также работает быстро на разреженных и связных графах, так как они имеют относительно меньшее количество ребер, но его эффективность снижается на полных графах, где время обработки скачет.


## 2)	a. Времени работы от числа вершин
### Полный граф
![Alt text](/grafics/image-19.png)
### Разреженный граф
![Alt text](/grafics/image-20.png)
### Связный граф
![Alt text](/grafics/image-21.png)
## Вывод по графикам
Алгоритмы проявляют одинаковое поведение на полных, связных и разреженных графах: наиболее медленным является алгоритм Флойда-Уоршелла, а наиболее быстрым - алгоритм Поиска А*.

## 2)	a. Времени работы от числа ребер
### Полный граф
![Alt text](/grafics/image-22.png)
### Разреженный граф
![Alt text](/grafics/image-23.png)
### Связный граф
![Alt text](/grafics/image-24.png)
## Вывод по графикам
Графики, которые отображают зависимость времени от количества ребер, проявляют ту же тенденцию, что и графики, отображающие зависимость времени от количества вершин. Для полных и разреженных графов алгоритмы демонстрируют одинаковое поведение: самый медленный – алгоритм Флойда-Уоршелла, а самый быстрый – алгоритм поиска А*.

# Вывод
Для графов с ребрами весом от 1 до 10, рекомендуется использовать алгоритм Форда-Беллмана или Поиск А*. Алгоритм Форда-Беллмана может использоваться для разреженных графов, но его эффективность снижается при наличии отрицательных ребер или циклов. Поиск А* требует определения эвристической функции, но может быть эффективным для разреженных графов, если он правильно настроен. Алгоритмы Дейкстры и Флойда-Уоршелла лучше всего работают на разреженных графах, а Форда-Беллмана - на разреженных и связных графах. Однако, эффективность всех алгоритмов ухудшается на полных графах.
## Подробнее
Для полного графа сложность алгоритма Дейкстры составляет O(n^2), где n - количество вершин в графе.
Для связного графа сложность алгоритма Дейкстры также составляет O(n^2), если использовать матрицу смежности для хранения графа. Однако, если использовать более эффективное представление графа, такое как список смежности, то сложность алгоритма может быть улучшена до O(n log n).
Для разреженного графа сложность алгоритма Дейкстры составляет O((n+m) log n), где m - количество ребер в графе.

Сложность алгоритма Флойда-Уоршелла для полного графа составляет O(n^3), где n - количество вершин в графе.
Для связного графа сложность алгоритма также составляет O(n^3), так как алгоритм обрабатывает все вершины и все ребра графа.
Для разреженного графа сложность алгоритма может быть улучшена до O(n^2 log n) или даже O(n^2), если использовать оптимизации, такие как алгоритм Дейкстры для поиска кратчайших путей на каждой итерации алгоритма Флойда-Уоршелла.

Для полного графа алгоритм Форда-Беллмана имеет сложность O(n^3), где n — количество вершин в графе. Это связано с тем, что для каждой вершины алгоритм проходит по всем остальным вершинам, что дает сложность O(n^2), а также выполняется n итераций, что дает общую сложность O(n^3).
Для связного графа с m ребрами алгоритм Форда-Беллмана имеет сложность O(nm), где n — количество вершин в графе. Это связано с тем, что алгоритм проходит по всем ребрам графа и выполняется n-1 итераций, что дает общую сложность O(nm).
Для разреженного графа (т.е. графа, в котором количество ребер много меньше, чем количество вершин) алгоритм Форда-Беллмана имеет сложность O(nm), где m — количество ребер в графе. Это связано с тем, что алгоритм проходит по всем ребрам графа и выполняется n-1 итераций, что дает общую сложность O(nm).

Для полного графа сложность алгоритма Поиск А* составляет O(b^d), где b - среднее количество дочерних вершин для каждой вершины, а d - глубина поиска. В полном графе среднее количество дочерних вершин для каждой вершины равно n-1, где n - количество вершин в графе, поэтому сложность алгоритма Поиск А* для полного графа равна O(n^d).
Для связного графа сложность алгоритма Поиск А* также может быть оценена как O(b^d), но может быть улучшена, если использовать более точные эвристические оценки расстояния до целевой вершины, такие как евклидово расстояние между вершинами. В этом случае сложность алгоритма будет зависеть от качества эвристики.
Для разреженного графа сложность алгоритма Поиск А* может быть значительно улучшена, поскольку в разреженном графе количество ребер меньше, чем в полном или связном графе. В этом случае сложность алгоритма будет зависеть от качества эвристики и количества ребер в графе, и может быть оценена как O(b^d), где b - среднее количество дочерних вершин для каждой вершины, а d - глубина поиска.
